

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ENUM, ELSE, CONST, IF, DO, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE;
terminal THIS, FOREACH, PLUS, MINUS, MUL, DIV, PERCENT, EQUALS_EQUALS, NOT_EQUALS;
terminal GT, GTE, LT, LTE, AND, OR, EQUALS, INCREMENT, DECREMENT, SEMICOLON, COLON, COMMA, DOT;
terminal LEFT_ROUND_PARENTHESES, RIGHT_ROUND_PARENTHESES, LEFT_SQUARE_PARENTHESES, RIGHT_SQUARE_PARENTHESES;
terminal LEFT_WIGGLY_PARENTHESES, RIGHT_WIGGLY_PARENTHESES, ARROW;

terminal Integer NUMCONST;
terminal String IDENT;
terminal Boolean BOOLCONST;
terminal Character CHARCONST;

nonterminal ConstDeclList ConstDeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal OtherConstList OtherConstList;
nonterminal VarDecl VarDecl;
nonterminal FirstVarDecl FirstVarDecl;
nonterminal OtherVarDeclList OtherVarDeclList;
nonterminal ClassDecl ClassDecl;
nonterminal Extension Extension;
nonterminal VarDeclList VarDeclList;
nonterminal ConstructorMethodLists ConstructorMethodLists;
nonterminal ConstructorDeclList ConstructorDeclList;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal FormParsOptional FormParsOptional;
nonterminal StatementList StatementList;
nonterminal MethodDecl MethodDecl;
nonterminal ReturnType ReturnType;
nonterminal FormPars FormPars;
nonterminal OptionalSquares OptionalSquares;
nonterminal TypeIdentList TypeIdentList;
nonterminal Statement Statement;
nonterminal Unmatched Unmatched;
nonterminal Matched Matched;
nonterminal OptionalExpr OptionalExpr;
nonterminal OptionalNumConst OptionalNumConst;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal DsgStmtEnd DsgStmtEnd;
nonterminal OptionalActPars OptionalActPars;
nonterminal OptionalDesignator OptionalDesignator;
nonterminal OptionalDesignatorList OptionalDesignatorList;
nonterminal ActPars ActPars;
nonterminal ExprList ExprList;
nonterminal ConditionIF ConditionIF;
nonterminal ConditionWHILE ConditionWHILE;
nonterminal CondTermOrList CondTermOrList;
nonterminal CondTerm CondTerm;
nonterminal CondFactAndList CondFactAndList;
nonterminal CondFact CondFact;
nonterminal OptionalRelopExpr OptionalRelopExpr;
nonterminal Expr Expr;
nonterminal OptMinus OptMinus;
nonterminal AddopTermList AddopTermList;
nonterminal Term Term;
nonterminal MulopFactorList MulopFactorList;
nonterminal Factor Factor;
nonterminal OptOptActPars OptOptActPars;
nonterminal ExprOrActPars ExprOrActPars;
nonterminal Designator Designator;
nonterminal IdentExprList IdentExprList;
nonterminal Label Label;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal DesignatorFE DesignatorFE;
nonterminal ElseElse ElseElse;
nonterminal FirstConstructorDecl FirstConstructorDecl;
nonterminal Lists Lists;
nonterminal MethodDecl2 MethodDecl2;
nonterminal MethodDeclList2 MethodDeclList2;
nonterminal ConstTail ConstTail;
nonterminal IdentSquares IdentSquares;
nonterminal ClassVarDecl ClassVarDecl;
nonterminal ClassVarDeclList ClassVarDeclList;
nonterminal FirstClassVarDecl FirstClassVarDecl;
nonterminal OtherClassVarDeclList OtherClassVarDeclList;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program;
nonterminal rs.etf.pp1.symboltable.concepts.Struct FirstConst, Type;

precedence left ELSE;

/* PROGRAM */

Program ::= (Program) PROGRAM ProgName:p ConstDeclList:C1 LEFT_WIGGLY_PARENTHESES MethodDeclList:M2 RIGHT_WIGGLY_PARENTHESES {: RESULT=new Program(p, C1, M2); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

ConstDeclList ::= (ConstDeclListConst) ConstDeclList:C1 ConstDecl:C2 {: RESULT=new ConstDeclListConst(C1, C2); RESULT.setLine(C1left); :} |
				  (ConstDeclListVar) ConstDeclList:C1 VarDecl:V2 {: RESULT=new ConstDeclListVar(C1, V2); RESULT.setLine(C1left); :}   |
				  (ConstDeclListClass) ConstDeclList:C1 ClassDecl:C2 {: RESULT=new ConstDeclListClass(C1, C2); RESULT.setLine(C1left); :} |
				  (NoConstDeclList) {: RESULT=new NoConstDeclList(); :} /* epsilon */;
				  
MethodDeclList ::= (MethodDeclListX) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListX(M1, M2); RESULT.setLine(M1left); :} |
				   (NoMethodDeclList) {: RESULT=new NoMethodDeclList(); :} /* epsilon */;
				   
/* CONST DECL */		   
				   
ConstDecl ::= (ConstDeclX) CONST Type:type IDENT:name EQUALS FirstConst:F1 OtherConstList:O2 SEMICOLON {: RESULT=new ConstDeclX(type, name, F1, O2); RESULT.setLine(typeleft); :} |
			  (ConstDeclError) error:l {: parser.report_error("Greska u deklaraciji globalnih konstanti u liniji " + lleft, null); :} SEMICOLON {: RESULT=new ConstDeclError(); :};

FirstConst ::= (FirstConstNum) NUMCONST:value {: RESULT=new FirstConstNum(value); RESULT.setLine(valueleft); :} |
			   (FirstConstChar) CHARCONST:value {: RESULT=new FirstConstChar(value); RESULT.setLine(valueleft); :} |
			   (FirstConstBool) BOOLCONST:value {: RESULT=new FirstConstBool(value); RESULT.setLine(valueleft); :};
			   
OtherConstList ::= (OtherConstListX) OtherConstList:O1 COMMA ConstTail:C2 {: RESULT=new OtherConstListX(O1, C2); RESULT.setLine(O1left); :} |
				   (NoOtherConstList) {: RESULT=new NoOtherConstList(); :} /* epsilon */;
				   
ConstTail ::= (ConstTailX) IDENT:name EQUALS FirstConst:F1 {: RESULT=new ConstTailX(name, F1); RESULT.setLine(nameleft); :} |
			  (ConstTailError) error:l {: parser.report_error("Greska u deklaraciji globalnih konstanti u liniji " + lleft, null); :} {: RESULT=new ConstTailError(); :};

/* VAR DECL */
				   
VarDecl ::= (VarDeclX) Type:T1 FirstVarDecl:F2 OtherVarDeclList:O3 SEMICOLON {: RESULT=new VarDeclX(T1, F2, O3); RESULT.setLine(T1left); :};

ClassVarDecl ::= (ClassVarDeclX) Type:T1 FirstClassVarDecl:F2 OtherClassVarDeclList:O3 SEMICOLON {: RESULT=new ClassVarDeclX(T1, F2, O3); RESULT.setLine(T1left); :} |
				 (ClassVarDeclError) error:l {: parser.report_error("Greska u deklaraciji polja klase u liniji " + lleft, null); :} {: RESULT=new ClassVarDeclError(); :} //|
				 //(ClassVarDeclErrorWiggly) error LEFT_WIGGLY_PARENTHESES:l {: parser.report_error("Greska u deklaraciji polja klase u liniji " + lleft, null); :}
				 ;

FirstVarDecl ::= (FirstVarDeclIdentOnly) IDENT:I1 {: RESULT=new FirstVarDeclIdentOnly(I1); RESULT.setLine(I1left); :} |
				 (FirstVarDeclArrayIdent) IDENT:I1 LEFT_SQUARE_PARENTHESES RIGHT_SQUARE_PARENTHESES {: RESULT=new FirstVarDeclArrayIdent(I1); RESULT.setLine(I1left); :} |
				 (FirstVarDeclError) error:l {: parser.report_error("Greska u deklaraciji globalnih varijabli u liniji " + lleft, null); :} {: RESULT=new FirstVarDeclError(); :};
				 
FirstClassVarDecl ::= (FirstClassVarDeclIdentOnly) IDENT:I1 {: RESULT=new FirstClassVarDeclIdentOnly(I1); RESULT.setLine(I1left); :} |
				 	  (FirstClassVarDeclArrayIdent) IDENT:I1 LEFT_SQUARE_PARENTHESES RIGHT_SQUARE_PARENTHESES {: RESULT=new FirstClassVarDeclArrayIdent(I1); RESULT.setLine(I1left); :};
				 
OtherVarDeclList ::= (OtherVarDeclListX) OtherVarDeclList:O1 COMMA FirstVarDecl:F2 {: RESULT=new OtherVarDeclListX(O1, F2); RESULT.setLine(O1left); :} |
					 (OtherVarDeclListError) error:l {: parser.report_error("Greska u deklaraciji globalnih varijabli u liniji " + lleft, null); :} {: RESULT=new OtherVarDeclListError(); :} |
					 (NoOtherVarDeclList) {: RESULT=new NoOtherVarDeclList(); :} /* epsilon */;
					 
OtherClassVarDeclList ::= (OtherClassVarDeclListX) OtherVarDeclList:O1 COMMA FirstVarDecl:F2 {: RESULT=new OtherClassVarDeclListX(O1, F2); RESULT.setLine(O1left); :} |
					 	  (NoOtherClassVarDeclList) {: RESULT=new NoOtherClassVarDeclList(); :} /* epsilon */;
					 
/* CLASS DECL */

ClassDecl ::= (ClassDecl) CLASS IDENT:I1 Extension:E2 LEFT_WIGGLY_PARENTHESES ClassVarDeclList:C3 ConstructorMethodLists:C4 RIGHT_WIGGLY_PARENTHESES {: RESULT=new ClassDecl(I1, E2, C3, C4); RESULT.setLine(I1left); :};

Extension ::= (ExtensionX) EXTENDS Type:T1 {: RESULT=new ExtensionX(T1); RESULT.setLine(T1left); :} |
			  (ExtensionError) error:l {: parser.report_error("Greska u proširenju natklase u liniji " + lleft, null); :} {: RESULT=new ExtensionError(); :}|
			  (NoExtension) {: RESULT=new NoExtension(); :} /* epsilon */;
			  
ClassVarDeclList ::= (ClassVarDeclListX) ClassVarDeclList:C1 ClassVarDecl:C2 {: RESULT=new ClassVarDeclListX(C1, C2); RESULT.setLine(C1left); :} |
					 (NoClassVarDeclList) {: RESULT=new NoClassVarDeclList(); :} /* epsilon */;

VarDeclList ::= (VarDeclListX) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclListX(V1, V2); RESULT.setLine(V1left); :} |
				(NoVarDeclList) {: RESULT=new NoVarDeclList(); :} /* epsilon */;
				
ConstructorMethodLists ::= (ConstructorMethodListsX) LEFT_WIGGLY_PARENTHESES Lists:L1 RIGHT_WIGGLY_PARENTHESES {: RESULT=new ConstructorMethodListsX(L1); RESULT.setLine(L1left); :} |
						   (NoConstructorMethodLists) {: RESULT=new NoConstructorMethodLists(); :} /* epsilon */;

Lists ::= (Lists1) IDENT:I1 LEFT_ROUND_PARENTHESES ConstructorDeclList:C2 IDENT:I3 IDENT:I4 MethodDeclList2:M5 {: RESULT=new Lists1(I1, C2, I3, I4, M5); RESULT.setLine(I1left); :} |
		  (Lists5) IDENT:I1 LEFT_ROUND_PARENTHESES ConstructorDeclList:C2 VOID IDENT:I3 MethodDeclList2:M4 {: RESULT=new Lists5(I1, C2, I3, M4); RESULT.setLine(I1left); :} |
		  (Lists6) IDENT:I1 LEFT_ROUND_PARENTHESES ConstructorDeclList:C2 {: RESULT=new Lists6(I1, C2); RESULT.setLine(I1left); :} |
		  (Lists2) IDENT:I1 IDENT:I2 MethodDeclList2:M3 {: RESULT=new Lists2(I1, I2, M3); RESULT.setLine(I1left); :} |
		  (Lists3) VOID IDENT:I1 MethodDeclList2:M2 {: RESULT=new Lists3(I1, M2); RESULT.setLine(I1left); :} |
		  (Lists4) {: RESULT=new Lists4(); :} /* epsilon */;
		  
MethodDeclList2 ::= (MDL21) MethodDeclList2:M1 IDENT:I2 IDENT:I3 MethodDecl2:M4 {: RESULT=new MDL21(M1, I2, I3, M4); RESULT.setLine(M1left); :} |
				   (MDL22) MethodDeclList2:M1 VOID IDENT:I2 MethodDecl2:M3 {: RESULT=new MDL22(M1, I2, M3); RESULT.setLine(M1left); :} |
				   (MDL23) MethodDecl2:M1 {: RESULT=new MDL23(M1); RESULT.setLine(M1left); :};
				   
MethodDecl2 ::= LEFT_ROUND_PARENTHESES FormParsOptional:F1 RIGHT_ROUND_PARENTHESES VarDeclList:V2 LEFT_WIGGLY_PARENTHESES StatementList:S3 RIGHT_WIGGLY_PARENTHESES {: RESULT=new MethodDecl2Derived1(F1, V2, S3); RESULT.setLine(F1left); :};

ConstructorDeclList ::= (ConstructorDeclListX) ConstructorDeclList:C1 IDENT:I2 LEFT_ROUND_PARENTHESES FirstConstructorDecl:F3 {: RESULT=new ConstructorDeclListX(C1, I2, F3); RESULT.setLine(C1left); :} |
						(NoConstructorDeclList) FirstConstructorDecl:F1 {: RESULT=new NoConstructorDeclList(F1); RESULT.setLine(F1left); :};
						
FirstConstructorDecl ::= FormParsOptional:F1 RIGHT_ROUND_PARENTHESES VarDeclList:V2 LEFT_WIGGLY_PARENTHESES StatementList:S3 RIGHT_WIGGLY_PARENTHESES {: RESULT=new FirstConstructorDeclDerived1(F1, V2, S3); RESULT.setLine(F1left); :};

/* CONSTRUCTOR DECL */

ConstructorDecl ::= (ConstructorDecl) IDENT:I1 LEFT_ROUND_PARENTHESES FormParsOptional:F2 RIGHT_ROUND_PARENTHESES VarDeclList:V3 LEFT_WIGGLY_PARENTHESES StatementList:S4 RIGHT_WIGGLY_PARENTHESES {: RESULT=new ConstructorDecl(I1, F2, V3, S4); RESULT.setLine(I1left); :};

FormParsOptional ::= (FormParsOptionalX) FormPars:F1 {: RESULT=new FormParsOptionalX(F1); RESULT.setLine(F1left); :} |
					(NoFormParsOptional) {: RESULT=new NoFormParsOptional(); :} /* epsilon */;
					
StatementList ::= (StatementListX) StatementList:S1 Statement:S2 {: RESULT=new StatementListX(S1, S2); RESULT.setLine(S1left); :} |
				  (NoStatementList) {: RESULT=new NoStatementList(); :} /* epsilon */;
			
/* METHOD DECL */

MethodDecl ::= (MethodDecl) ReturnType:R1 IDENT:I2 LEFT_ROUND_PARENTHESES FormParsOptional:F3 RIGHT_ROUND_PARENTHESES VarDeclList:V4 LEFT_WIGGLY_PARENTHESES StatementList:S5 RIGHT_WIGGLY_PARENTHESES {: RESULT=new MethodDecl(R1, I2, F3, V4, S5); RESULT.setLine(R1left); :};

ReturnType ::= (ReturnTypeX) Type:T1 {: RESULT=new ReturnTypeX(T1); RESULT.setLine(T1left); :} |
			   (NoReturnType) VOID {: RESULT=new NoReturnType(); :};
			   
/* FORM PARS */

FormPars ::= (FormPars) IdentSquares:I1 TypeIdentList:T2 {: RESULT=new FormPars(I1, T2); RESULT.setLine(I1left); :};

OptionalSquares ::= (OptionalSquaresX) LEFT_SQUARE_PARENTHESES RIGHT_SQUARE_PARENTHESES {: RESULT=new OptionalSquaresX(); :} |
					(NoOptionalSquares) {: RESULT=new NoOptionalSquares(); :} /* epsilon */;
					
TypeIdentList ::= (TypeIdentListX) TypeIdentList:T1 COMMA IdentSquares:I2 {: RESULT=new TypeIdentListX(T1, I2); RESULT.setLine(T1left); :} |
				  (NoTypeIdentList) {: RESULT=new NoTypeIdentList(); :} /* epsilon */;
				  
IdentSquares ::= (IdentSquaresX) Type:T1 IDENT:I2 OptionalSquares:O3 {: RESULT=new IdentSquaresX(T1, I2, O3); RESULT.setLine(T1left); :} |
				 (IdentSquaresError) error:l {: parser.report_error("Greska u deklaraciji formalnog parametra funkcije u liniji " + lleft, null); :} {: RESULT=new IdentSquaresError(); :};
				  
/* TYPE */

Type ::= (Type) IDENT:name {: RESULT=new Type(name); RESULT.setLine(nameleft); :};

/* STATEMENT */

Statement ::= (MatchedStmt) Matched:M1 {: RESULT=new MatchedStmt(M1); RESULT.setLine(M1left); :} |
			  (UnmatchedStmt) Unmatched:U1 {: RESULT=new UnmatchedStmt(U1); RESULT.setLine(U1left); :};
			  
Unmatched ::= (UnmatchedIf) IF LEFT_ROUND_PARENTHESES ConditionIF:C1 RIGHT_ROUND_PARENTHESES Statement:S2 {: RESULT=new UnmatchedIf(C1, S2); RESULT.setLine(C1left); :} |
			  (UnmatchedIfElse) IF LEFT_ROUND_PARENTHESES ConditionIF:C1 RIGHT_ROUND_PARENTHESES Matched:M2 ElseElse:E3 Unmatched:U4 {: RESULT=new UnmatchedIfElse(C1, M2, E3, U4); RESULT.setLine(C1left); :};

Matched ::= (DesigStmt) DesignatorStatement:D1 {: RESULT=new DesigStmt(D1); RESULT.setLine(D1left); :} |
			(MatchedIfElseStmt) IF LEFT_ROUND_PARENTHESES ConditionIF:C1 RIGHT_ROUND_PARENTHESES Matched:M2 ElseElse:E3 Matched:M4 {: RESULT=new MatchedIfElseStmt(C1, M2, E3, M4); RESULT.setLine(C1left); :} |
			(WhileStmt) WHILE LEFT_ROUND_PARENTHESES ConditionWHILE:C1 RIGHT_ROUND_PARENTHESES Statement:S2 {: RESULT=new WhileStmt(C1, S2); RESULT.setLine(C1left); :} |
			(BreakStmt) BREAK SEMICOLON {: RESULT=new BreakStmt(); :} |
			(ContinueStmt) CONTINUE SEMICOLON {: RESULT=new ContinueStmt(); :} |
			(ReturnStmt) RETURN OptionalExpr:O1 SEMICOLON {: RESULT=new ReturnStmt(O1); RESULT.setLine(O1left); :} |
			(ReadStmt) READ LEFT_ROUND_PARENTHESES Designator:D1 RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :} |
			(PrintStmt) PRINT LEFT_ROUND_PARENTHESES Expr:E1 OptionalNumConst:O2 RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new PrintStmt(E1, O2); RESULT.setLine(E1left); :} |
			(ForeachStmt) DesignatorFE:D1 LEFT_ROUND_PARENTHESES IDENT:I2 ARROW Statement:S3 RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new ForeachStmt(D1, I2, S3); RESULT.setLine(D1left); :} |
			(BlockStmt) LEFT_WIGGLY_PARENTHESES StatementList:S1 RIGHT_WIGGLY_PARENTHESES {: RESULT=new BlockStmt(S1); RESULT.setLine(S1left); :};	
			
ElseElse ::= (ElseElse) ELSE {: RESULT=new ElseElse(); :};	  
				 
OptionalExpr ::= (OptionalExprX) Expr:E1 {: RESULT=new OptionalExprX(E1); RESULT.setLine(E1left); :} |
				 (NoOptionalExpr) {: RESULT=new NoOptionalExpr(); :} /* epsilon */;
				 
OptionalNumConst ::= (OptionalNumConstX) COMMA NUMCONST:N1 {: RESULT=new OptionalNumConstX(N1); RESULT.setLine(N1left); :} |
					 (NoOptionalNumConst) {: RESULT=new NoOptionalNumConst(); :} /* epsilon */;

/* DESIGNATOR STATEMENT */

DesignatorStatement ::= (FirstTypeDesignatorStmt) Designator:D1 DsgStmtEnd:D2 SEMICOLON {: RESULT=new FirstTypeDesignatorStmt(D1, D2); RESULT.setLine(D1left); :} |
						(SecondTypeDesignatorStmt) LEFT_SQUARE_PARENTHESES OptionalDesignator:O1 OptionalDesignatorList:O2 RIGHT_SQUARE_PARENTHESES EQUALS Designator:D3 SEMICOLON {: RESULT=new SecondTypeDesignatorStmt(O1, O2, D3); RESULT.setLine(O1left); :} |
						(ErrorDesignatorStmt) error SEMICOLON:l {: parser.report_error("Greska u konstrukciji iskaza dodele u liniji " + lleft, null); :} {: RESULT=new ErrorDesignatorStmt(); :};
						
DsgStmtEnd ::= (AssignDsgStmtEnd) Assignop:A1 Expr:E2 {: RESULT=new AssignDsgStmtEnd(A1, E2); RESULT.setLine(A1left); :} |
			   (ActParsDsgStmtEnd) LEFT_ROUND_PARENTHESES OptionalActPars:O1 RIGHT_ROUND_PARENTHESES {: RESULT=new ActParsDsgStmtEnd(O1); RESULT.setLine(O1left); :} |
			   (IncDsgStmtEnd) INCREMENT {: RESULT=new IncDsgStmtEnd(); :} |
			   (DecDsgStmtEnd) DECREMENT {: RESULT=new DecDsgStmtEnd(); :};

OptionalActPars ::= (OptionalActParsX) ActPars:A1 {: RESULT=new OptionalActParsX(A1); RESULT.setLine(A1left); :} |
				    (NoOptionalActPars) {: RESULT=new NoOptionalActPars(); :} /* epsilon */;
				    
OptionalDesignator ::= (OptionalDesignatorX) Designator:D1 {: RESULT=new OptionalDesignatorX(D1); RESULT.setLine(D1left); :} |
					   (NoOptionalDesignator) {: RESULT=new NoOptionalDesignator(); :} /* epsilon */;
					   
OptionalDesignatorList ::= (OptionalDesignatorListX) OptionalDesignatorList:O1 COMMA OptionalDesignator:O2 {: RESULT=new OptionalDesignatorListX(O1, O2); RESULT.setLine(O1left); :} |
						   (NoOptionalDesignatorList) {: RESULT=new NoOptionalDesignatorList(); :} /* epsilon */;
						   
/* ACT PARS */

ActPars ::= (ActPars) Expr:E1 ExprList:E2 {: RESULT=new ActPars(E1, E2); RESULT.setLine(E1left); :};

ExprList ::= (ExprListX) ExprList:E1 COMMA Expr:E2 {: RESULT=new ExprListX(E1, E2); RESULT.setLine(E1left); :} |
			 (NoExprList) {: RESULT=new NoExprList(); :} /* epsilon */;

/* CONDITION */

ConditionIF ::= (ConditionIFX) CondTerm:C1 CondTermOrList:C2 {: RESULT=new ConditionIFX(C1, C2); RESULT.setLine(C1left); :} |
				(ConditionIFError) error:l {: parser.report_error("Greska u logickom izrazu za IF grananje u liniji " + lleft, null); :} {: RESULT=new ConditionIFError(); :};

ConditionWHILE ::= (ConditionWHILE) CondTerm:C1 CondTermOrList:C2 {: RESULT=new ConditionWHILE(C1, C2); RESULT.setLine(C1left); :};

CondTermOrList ::= (CondTermOrListX) CondTermOrList:C1 OR CondTerm:C2 {: RESULT=new CondTermOrListX(C1, C2); RESULT.setLine(C1left); :} |
				   (NoCondTermOrList) {: RESULT=new NoCondTermOrList(); :} /* epsilon */;

/* COND TERM */

CondTerm ::= (CondTerm) CondFact:C1 CondFactAndList:C2 {: RESULT=new CondTerm(C1, C2); RESULT.setLine(C1left); :};

CondFactAndList ::= (CondFactAndListX) CondFactAndList:C1 AND CondFact:C2 {: RESULT=new CondFactAndListX(C1, C2); RESULT.setLine(C1left); :} |
					(NoCondFactAndList) {: RESULT=new NoCondFactAndList(); :} /* epsilon */;

/* COND FACT */

CondFact ::= (CondFact) Expr:E1 OptionalRelopExpr:O2 {: RESULT=new CondFact(E1, O2); RESULT.setLine(E1left); :};

OptionalRelopExpr ::= (OptionalRelopExprX) Relop:R1 Expr:E2 {: RESULT=new OptionalRelopExprX(R1, E2); RESULT.setLine(R1left); :} |
					  (NoOptionalRelopExpr) {: RESULT=new NoOptionalRelopExpr(); :} /* epsilon */;
					  
/* EXPR */

Expr ::= (Expr) OptMinus:O1 Term:T2 AddopTermList:A3 {: RESULT=new Expr(O1, T2, A3); RESULT.setLine(O1left); :};

OptMinus ::= (OptMinusX) MINUS {: RESULT=new OptMinusX(); :} |
			 (NoOptMinus) {: RESULT=new NoOptMinus(); :} /* epsilon */;
			 
AddopTermList ::= (AddopTermListX) AddopTermList:A1 Addop:A2 Term:T3 {: RESULT=new AddopTermListX(A1, A2, T3); RESULT.setLine(A1left); :} |
				  (NoAddopTermList) {: RESULT=new NoAddopTermList(); :} /* epsilon */;
 				  
/* TERM */

Term ::= (Term) Factor:F1 MulopFactorList:M2 {: RESULT=new Term(F1, M2); RESULT.setLine(F1left); :};

MulopFactorList ::= (MulopFactorListX) MulopFactorList:M1 Mulop:M2 Factor:F3 {: RESULT=new MulopFactorListX(M1, M2, F3); RESULT.setLine(M1left); :} |
					(NoMulopFactorList) {: RESULT=new NoMulopFactorList(); :} /* epsilon */;
					
/* FACTOR */

Factor ::= (FactorActPars) Designator:D1 OptOptActPars:O2 {: RESULT=new FactorActPars(D1, O2); RESULT.setLine(D1left); :} |
		   (FactorNumConst) NUMCONST:N1 {: RESULT=new FactorNumConst(N1); RESULT.setLine(N1left); :} |
		   (FactorCharConst) CHARCONST:C1 {: RESULT=new FactorCharConst(C1); RESULT.setLine(C1left); :} |
		   (FactorBoolConst) BOOLCONST:B1 {: RESULT=new FactorBoolConst(B1); RESULT.setLine(B1left); :} |
		   (FactorExprActPars) NEW Type:T1 ExprOrActPars:E2 {: RESULT=new FactorExprActPars(T1, E2); RESULT.setLine(T1left); :} |
		   (FactorExpr) LEFT_ROUND_PARENTHESES Expr:E1 RIGHT_ROUND_PARENTHESES {: RESULT=new FactorExpr(E1); RESULT.setLine(E1left); :};

OptOptActPars ::= (OptOptActParsX) LEFT_ROUND_PARENTHESES OptionalActPars:O1 RIGHT_ROUND_PARENTHESES {: RESULT=new OptOptActParsX(O1); RESULT.setLine(O1left); :} |
				  (NoOptOptActPars) {: RESULT=new NoOptOptActPars(); :} /* epsilon */;

ExprOrActPars ::= (ExprOrActParsExpr) LEFT_SQUARE_PARENTHESES Expr:E1 RIGHT_SQUARE_PARENTHESES {: RESULT=new ExprOrActParsExpr(E1); RESULT.setLine(E1left); :} |
				  (ExprOrActParsActPars) LEFT_ROUND_PARENTHESES OptionalActPars:O1 RIGHT_ROUND_PARENTHESES {: RESULT=new ExprOrActParsActPars(O1); RESULT.setLine(O1left); :};
			  
/* DESIGNATOR */

Designator ::= (Designator) IDENT:I1 IdentExprList:I2 {: RESULT=new Designator(I1, I2); RESULT.setLine(I1left); :};

DesignatorFE ::= (DesignatorFE) IDENT:I1 IdentExprList:I2 DOT FOREACH {: RESULT=new DesignatorFE(I1, I2); RESULT.setLine(I1left); :};

IdentExprList ::= (IdentExprListIdent) IdentExprList:I1 DOT IDENT:I2 {: RESULT=new IdentExprListIdent(I1, I2); RESULT.setLine(I1left); :} |
				  (IdentExprListExpr) IdentExprList:I1 LEFT_SQUARE_PARENTHESES Expr:E2 RIGHT_SQUARE_PARENTHESES {: RESULT=new IdentExprListExpr(I1, E2); RESULT.setLine(I1left); :} |
				  (NoIdentExprList) {: RESULT=new NoIdentExprList(); :} /* epsilon */;
				  
/* LABEL */

Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};

/* ASSIGNOP */

Assignop ::= (Assignop) EQUALS {: RESULT=new Assignop(); :};

/* RELOP */

Relop ::= (RelopEq) EQUALS_EQUALS {: RESULT=new RelopEq(); :} |
		  (RelopNE) NOT_EQUALS {: RESULT=new RelopNE(); :} |
		  (RelopGT) GT {: RESULT=new RelopGT(); :} |
		  (RelopGTE) GTE {: RESULT=new RelopGTE(); :} |
		  (RelopLT) LT {: RESULT=new RelopLT(); :} |
		  (RelopLTE) LTE {: RESULT=new RelopLTE(); :};
		  
/* ADDOP */

Addop ::= (AddopP) PLUS {: RESULT=new AddopP(); :} |
		  (AddopM) MINUS {: RESULT=new AddopM(); :};
		  
/* MULOP */

Mulop ::= (MulopM) MUL {: RESULT=new MulopM(); :} |
		  (MulopD) DIV {: RESULT=new MulopD(); :} |
		  (MulopP) PERCENT {: RESULT=new MulopP(); :};
		  